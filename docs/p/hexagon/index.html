<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>A program for obscure mathematics...</title>
<link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAQAAAADrRVxmAAAACXBIWXMAAAMfAAADHwHmEQywAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAVZJREFUSMfd1EuOwyAMAFAQ0rAZNUfIUTga5GbsZtkrcINhyQLBYMgHG6ZddJcoSpOXDzY2ZZls7F5Q9iAzhyu/XsAomCm4AdRHYPUUNAH7GTgdRbZd+k6FCZgGZQPw/DV45dgIWw+rc3rrRvGrHcBrjmDzqocAIBCIsr+ERcYFwYNAfMj0QPC9pC+JIWNgpfJvQGXTQwJYCFgMegSHIWPIA/DaplO49UIuEy7qUR5gWakJHA+oXZhNZYBYQNQnlgaBKSthrRjRwJXfcu+ZA28A5fmF7yXWwKg+BgB9AJyxPtgGib8FQSCKjEcZQR7XqUUaTgiCgJME9vRPMEwREJk+McCKodUBDUvjiDTSfU4v2NPvwCqc7QHif3Bz6Ga9vZIYga5yVs9rO1Qf+uOnSw6yhnKu2Yurx+C/Ru8TVLuQl9HPtmx9CqCvTlYwxxz3eqhv3Htl/wEokJpySHNGkgAAAABJRU5ErkJggg==" rel="icon"/>
<style>
@media (prefers-color-scheme:dark) {body {background-color:#000;color:#FFF;}
a:visited {color:#C0F;}
a:link, a:hover, a:active {color:#0CF;}
}
@media print {body {max-width:8in;font-size:12px;margin:0;}
}
@media screen {body {font-family:sans-serif;max-width:35em;margin:22px auto 64px auto;padding:0 8px;}
}
body {overflow-wrap:break-word;}
@page {size:auto;margin:0.25in 0.5in 0.4in 0.5in;}
svg {fill:currentColor;}
img {max-width:100%;height:auto;}
hr {border-style:solid none;}
.content {margin:1em 0;}
.content hr {padding:0;margin:0;border:none;text-align:center;}
.content hr:after {font-size:150%;content:"* \A0 * \A0 *";display:block;position:relative;}
.rightside {text-align:right;}
.centered {text-align:center;}
pre {overflow-x:auto;}
code.language-go {tab-size:4;}
.byline > * {display:inline-block;border-style:solid;border-width:thin;padding:3px 8px;border-radius:5px;text-align:initial;}
.byline {text-align:right;}
.box {border-style:solid;border-width:thin;margin:8px 0;padding:0 8px;}
a.hiddenlink:link {background:inherit;color:inherit;text-decoration:none;}
a.hiddenlink:visited {background:inherit;color:inherit;text-decoration:none;}
a.hiddenlink:active {background:inherit;color:inherit;text-decoration:none;}
ul,ol {padding-left:30px;}
table.border {border-collapse:collapse;margin:8px auto;}
table.border tr > * {border-style:solid;border-width:thin;padding:3px 8px;border-radius:5px;}
.tophead {text-align:center;margin:1ex auto 0 auto;max-width:35em;}
.tightmargins li > ul > li {list-style-type:square;}
.tightmargins h1,
.tightmargins h2,
.tightmargins p,
.tightmargins ul {margin:0.5ex 0;}
.tightmargins li > ul {margin:0 0 0.5ex 0;}
.tightmargins ul {padding-left:30px;}
.tightmargins li {margin:0 0 0.5ex 0;}
.plainlink a:link,
.plainlink a:visited,
.plainlink a:hover,
.plainlink a:active {color:inherit;text-decoration:underline;}
.nolink a:link,
.nolink a:visited,
.nolink a:hover,
.nolink a:active {color:inherit;text-decoration:none;}
div.lcr {display:grid;grid-template-columns:auto auto auto;}
ul.flat {list-style-type:none;margin:16px 0;padding:0;}
ul.flat li {display:inline;}
ul.flat li::after {content:"]";}
ul.flat li::before {content:"[";}
</style>
<!--
Copyright 2002-2023 Hal Canary. ALL RIGHTS RESERVED.
-->
</head>
<body>
<div class="tophead" role="banner">
<svg aria-label="Hal W Canary 3" role="img" viewBox="-200 0 800 91" width="100%">
<title>Hal W Canary 3</title>
<rect height="4" width="180" x="-200" y="43" />
<rect height="4" width="180" x="420" y="43" />
<path d="M 34 0 C 30 6 28 13 27 20 C 26 23 27 28 25 31 C 21 35 13 34 9 35 C 12
24 9 13 12 3 L 8 2 C 4 18 6 36 3 53 C 2 58 -1 66 5 70 C 6 59 8 49 9 39 C 14 39
19 38 25 38 C 25 49 23 61 23 73 C 30 70 27 60 27 54 C 28 36 31 17 38 1 L 34 0" />
<path d="M 50 31 C 46 38 44 45 41 53 C 40 56 39 60 40 64 L 42 64 C 44 59 45 54
46 49 C 48 50 49 51 52 52 C 50 57 52 63 57 66 C 58 61 56 56 56 51 C 59 50 61 49
64 47 C 61 46 58 46 56 45 C 53 42 53 34 52 31 L 50 31 z M 49 41 C 50 43 50 44
51 47 L 47 49 C 47 46 48 43 49 41 z" />
<path d="M 83 61 C 79 59 74 60 71 57 C 68 53 70 41 71 37 C 64 39 66 46 65 52 C
65 54 64 58 66 60 C 70 65 79 65 83 61" />
<path d="M 107 13 C 104 23 104 36 108 47 C 111 54 114 63 121 54 C 122 52 123
51 124 50 C 125 51 127 53 129 54 C 134 57 139 55 143 50 C 149 43 153 34 157 26
C 159 21 162 17 163 13 L 158 13 C 154 23 149 34 142 43 C 141 46 138 48 137 52 C
132 50 129 48 127 44 L 125 45 C 124 43 124 43 123 43 C 121 46 118 49 116 53 C
114 48 112 45 111 41 C 109 31 109 22 110 13 L 107 13" />
<path d="M 153 53 L 152 56 C 154 56 155 56 158 56 C 156 54 155 53 153 53" />
<path d="M 211 55 C 206 56 203 58 199 57 C 189 57 180 46 182 36 C 183 27 190
18 198 13 C 205 9 210 11 218 12 C 213 3 204 5 198 8 C 188 14 175 29 177 42 C
178 51 187 60 196 62 C 201 63 212 63 211 55" />
<path d="M 230.2793 37.738281 C 229.89349 37.729675 229.46875 37.8125 229 38 C
226 39 224 42 223 45 C 220 50 218 57 220 64 C 223 61 223 58 224 54 C 232 54 231
62 235 69 C 239 64 232 56 241 54 C 239 51 238 50 235 50 C 234.09375 46.375
234.00873 37.821472 230.2793 37.738281 z M 228 44 C 229 45 230 47 231 50 L 226
50 L 228 44 z" />
<path d="M 245 42 C 243 47 242 54 243 59 C 243 61 243 65 245 65 C 249 64 246
52 247 50 C 252 55 253 73 263 72 C 261 66 261 61 260 56 C 263 53 263 47 263 43
C 259 46 257 52 257 58 C 254 51 252 44 245 42" />
<path d="M 286 43 C 273 43 274 64 274 74 C 283 72 274 61 284 60 L 285 74 L 290
74 C 289 68 286 61 293 59 L 293 56 C 286 54 286 48 286 43 z M 282 49 C 283 51
283 53 284 56 L 279 57 C 279 54 280 51 282 49 z" />
<path d="M 304.79297 41.806641 C 301.8125 41.765625 297.875 44.5 297 48 C 295
54 295 64 297 71 C 300 68 300 66 301 62 C 303 65 306 70 310 73 C 315 76 316 69
316 66 C 310 67 308 63 305 59 C 307 58 310 58 312 55 C 315 51 312 44 306 42 C
305.625 41.875 305.21875 41.8125 304.79297 41.806641 z M 304.15039 47.570312 C
306.09 47.667908 308.375 49.34375 310 53 L 301 56 C 299.21875 50.65625
301.31558 47.427673 304.15039 47.570312 z" />
<path d="M 329 90 C 330 89 332 89 333 87 C 334 85 331 80 331 77 C 330 71 333
65 332 60 C 337 56 342 50 341 44 C 337 45 333 53 330 53 C 325 53 326 47 325 45
C 325 43 324 42 322 43 C 319 45 322 52 323 54 C 324 58 327 59 328 63 C 329 67
327 71 327 74 C 326 80 327 84 329 90" />
<path d="M 372 10 L 374 13 C 376 12 377 12 380 13 C 381 13 382 14 383 14 C 384
15 386 15 386 16 C 394 24 373 25 375 34 C 377 40 390 43 389 51 C 387 59 375 62
375 71 C 383 67 399 55 393 45 C 390 38 382 37 380 31 C 384 29 394 26 395 20 C
395 17 392 15 389 13 C 384 9 378 6 372 10" />
</svg>
</div>
<div><a href="https://mastodon.sdf.org/@hal_canary" rel="me"></a><a href="https://github.com/halcanary" rel="me"></a><a href="https://gitlab.com/halcanary" rel="me"></a><a href="https://twitter.com/halcanary" rel="me"></a><a href="https://www.facebook.com/hal.canary" rel="me"></a><a href="https://www.linkedin.com/in/halcanary" rel="me"></a></div>
<article role="main">
<h1>A program for obscure mathematics...</h1>
<p>This IS the pinnacle of my career.</p>
<p>By the way, you can use this code in accordance with the GNU GPL license.</p>
<p>hexagon.cpp</p>
<hr />
<pre><code>/* 
   (c) 2001-2003 Hal Canary, University of Wisconsin-Madison

   Licence Information:

	This program is free software; you can redistribute it and/or
	modify it under the terms of version 2 of the GNU General
	Public License as published by the Free Software Foundation.

	A copy of the licence can be found at:
			http://www.gnu.org/licenses/gpl.txt

	This program is distributed in the hope that it will be
	useful, but WITHOUT ANY WARRANTY; without even the implied
	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
	PURPOSE.  See the GNU General Public License for more details.

   How do I compile this?
   $ g++ -o hexagon hexagon.cpp
   
   What do the terminal matchings mean?
        1   2            
        |   |                             
   12   |   |   3              1   2		  
     \ / \ / \ /  	     o---o---o    
      |   |   |   	 12 / \ / \ / \ 3  
 11   |   |   |   4	   o---o---o---o  
   \ / \ / \ / \ /	11/ \ / \ / \ / \ 4
    |   |   |   | 	 o---o---o---o---o
    |   |   |   |      10 \ / \ / \ / \ / 5
   / \ / \ / \ / \	   o---o---o---o  
 10   |   |   |   5	 9  \ / \ / \ / 6  
      |   |   |   	     o---o---o    
     / \ / \ / \  	       8   7	  
    9   |   |   6  	 		  
        |   |     	 		  
        8   7         	 		                        
*/

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

/**
 * hexagon class.  
 * can print out all lozenge tilings of a particular size regular hexagon.
 * can print all of the dpfl terminal matchings.
 * Hal Canary, April 2001.
 **/

const int MAXSIZE = 50;

/**
 * class for a hexagon/GelfandSquare
 **/
class Hexagon {
public:
    /** 
     * constructor: makes the smallest gelfand square.
     **/
    Hexagon(int sizein);

    /**
     * default constructor:  sets size to 1.
     **/
    Hexagon();

    /**
     * changes the gelfand square.
     **/
    int iterate();

    /**
     * constructs two matrices that represent the matching/tiling.
     **/
    int makeBW();
    
    /**
     * prints out the tiling (assumes you've run makeBW).
     **/
    int printBW(ostream&amp; o);

    /**
     * prints out the gelfand square.
     **/
    int printGS(ostream&amp; o);

    /**
     * prints out all of the dpfl terminal matchings.
     * Assumes you've run makeBW.
     **/
    int printMatchings(ostream&amp; o);

private:
    //fields:
    int size;                             // size of the regular hexagon.
    int gelfand [MAXSIZE+1] [MAXSIZE+1] ; // GelfandSquare
    char black [2*MAXSIZE][2*MAXSIZE] ;   // black triangles
    char white [2*MAXSIZE][2*MAXSIZE] ;   // white triangles

    //functions:

    /**
     * Recursive Iteration function.
     * parameters: current position in GS.
     * returns 1 if we are done iterating, else 0
     **/
    int iterateR(int row, int col);       

    /**
     * matching function.
     * returns the terminal that matches the starting Terminal.
     **/
    int match(int startTerminal);       

    /**
     * Recursive flux Move function.
     * returns termianl on which the dpf line ends.
     **/
    int rmove(char type, int row, int col, char dir);

    /**
     * returns 0 if not a terminal.  
     * otherwise returns terminal number.
     **/
    int amterm(char type, int row, int col);
};

Hexagon::Hexagon(int sizein) { 
    size = sizein;
    if (size &gt; MAXSIZE) {
	size = MAXSIZE;
    }
    gelfand[0][0] = 0;
    for (int j=1; j &lt; size+1; j++) { 
	gelfand[0][j] = (2 * size) + 1;
    }
    for (int i=1; i &lt; size+1; i++) {
	for (int j=0; j &lt; size+1; j++) {
	    gelfand[i][j] = size-i+1;
	}
    }
}
Hexagon::Hexagon() { 
    size = 1;
    gelfand[0][0] = 0;
    for (int j=1; j &lt; size+1; j++) { 
	gelfand[0][j] = (2 * size) + 1;
    }
    for (int i=1; i &lt; size+1; i++) {
	for (int j=0; j &lt; size+1; j++) {
	    gelfand[i][j] = size-i+1;
	}
    }
}

int Hexagon::iterate() { 
    return iterateR(size, size);
}

int Hexagon::iterateR(int row, int col) {
    if (gelfand[row][col] &lt; gelfand[row-1][col]-1 ) {
	gelfand[row][col]++;
	return 0;
    } 
    else {
	if (col &gt; 1) {
	    if (iterateR(row, col-1) == 1) 
		return 1 ;
	    else { 
		gelfand[row][col] = gelfand[row][col-1];
		return 0;
	    }
	}
	else if (row &gt; 1) {
	    if (iterateR(row-1, size) == 1) 
		return 1 ;
	    else { 
		gelfand[row][col] = gelfand[row][col-1];
		return 0;
	    }
	}
	else if (row == 1 &amp;&amp; col == 1) 
	    return 1;
	else
	    return 40;
    }
}

int Hexagon::printGS(ostream&amp; o) {
    for (int i=0; i &lt; size+1; i++) {
	for (int j=0; j &lt; size+1; j++) {
	    o &lt;&lt; gelfand[i][j] &lt;&lt; '\t' ;
	}
	o &lt;&lt; endl;
    }
}

int Hexagon::makeBW() { 
    //black is either r, l, d, or ' '
    //white is either r, l, u, or ' '
    //start the empty bleg.
    for (int i=0; i &lt; 2*size; i++) {
	for (int j=0; j &lt; 2* size; j++) {
	    black[i][j] = '_' ;
	    white[i][j] = '_' ;
	}
    }   

    for (int i=0; i &lt; size; i++) {
	for (int j=0; j &lt; size-1-i; j++) {
	    black[i][j] = ' ' ;
	    white[2*size-i-1][2*size-j-1] = ' ' ;
	}
    }
    for (int i=size; i &lt; 2*size; i++) {
	for (int j=3*size-i-1 ; j &lt; 2*size; j++) {
	    black[i][j] = ' ' ;
	    white[2*size-i-1][2*size-j-1] = ' ' ;
	}
    }
    //insert the up-down tiles...
    for (int i=1; i &lt; size+1; i++) {
	for (int j=1; j &lt; size+1; j++) {
	    int rowblack = i+j-2;
	    int rowwhite = i+j-1;
	    int col = gelfand[i][j] -1 ;
	    white[rowwhite][col] = 'V';
	    black[rowblack][col] = 'A';
	}
    }

    //insert the left-right tiles...
    for (int i=0; i &lt; size; i++) {
	if (black[i][size-i-1] != 'A') {
	    black[i][size-i-1] = '&lt;';
	}
    }
    for (int i=0; i &lt; size; i++) {
	for (int j=size-i; j&lt; 2*size; j++) {
	    if (white[i][j] == 'V' ) {
		if (black[i][j] != 'A' ) {
		    black[i][j] = '&lt;' ;
		}
	    }
	    else if (black[i][j-1] == '&lt;') {
		white[i][j] = '&gt;' ;
		if (black[i][j] != 'A') {
		    black[i][j] = '&lt;';
		}
	    }
	    else {
		white[i][j] = '&lt;';
		black[i][j] = '&gt;';
	    }
	}
    }

    for (int i=size; i &lt; 2*size; i++) {
	if (white[i][0] != 'V') {
	    white[i][0] = '&lt;';
	}
    }
    for (int i=size; i &lt; 2*size; i++) {
	for (int j=0; j&lt; 3*size-i-1; j++) {
	    if (black[i][j]== 'A') {
		if (white[i][j+1] != 'V') {
		    white[i][j+1] = '&lt;' ;
		}
	    }
	    else if (white[i][j]== '&lt;') {
		black[i][j] = '&gt;';
		if (white[i][j+1] != 'V') {
		    white[i][j+1] = '&lt;' ;
		}
	    }
	    else {
		black[i][j] = '&lt;';
		white[i][j+1] = '&gt;';
	    }
	}
    }    
    return 0;
}    

int Hexagon::printBW(ostream&amp; o) { 
    for (int i=0; i &lt; 2*size; i++) {
	for (int j=0; j &lt; i; j++) {
	    o &lt;&lt; ' ' ;
	}
	for (int j=0; j &lt; 2* size; j++) {
	    if (i&gt;=size &amp;&amp; white[i][j]==' '){
		j = 2*size;
	    }
	    else {
		o &lt;&lt; white[i][j] ;
		o &lt;&lt; black[i][j] ;
	    }
	}
	o &lt;&lt; endl;
    }   
    return 0;
}

int Hexagon::printMatchings(ostream&amp; o) {
    for (int i=1 ; i &lt;= 6 * size ; i=i+2) {
	o &lt;&lt; i &lt;&lt; ':' &lt;&lt; match(i) &lt;&lt;  ' ' ;
    }
    o &lt;&lt; endl;
    return 0;
}

int Hexagon::match(int go) {
    if      (go &gt; 0      &amp;&amp; go &lt;=   size) { 
	return rmove('w', 0, go+size-1, 'd');
    }
    else if (go &gt; size   &amp;&amp; go &lt;= 2*size) { 
	return rmove('b', go-size-1, 2*size-1, 'l');
    }
    else if (go &gt; 2*size &amp;&amp; go &lt;= 3*size) {  
	return rmove('w', go-1-size, 4*size-go, 'l');
    }
    else if (go &gt; 3*size &amp;&amp; go &lt;= 4*size) {  
	return rmove('b', 2*size-1, 4*size-go, 'u');
    }
    else if (go &gt; 4*size &amp;&amp; go &lt;= 5*size) {  
	return rmove('w', 6*size - go, 0, 'r');
    }
    else if (go &gt; 5*size &amp;&amp; go &lt;= 6*size) {  
	return rmove('b', 6*size-go, go-5*size-1, 'r');
    }
    else {
	return 7000;
    }
}

int Hexagon::rmove(char type, int row, int col, char dir) { 
    //decide next tile/node.
    char newdir;
    int newrow;
    int newcol;
    char newtype;
    if (type == 'b') {
	char match = black[row][col];
	newtype = 'w';
	if      (match == 'A' &amp;&amp; dir == 'l') {  newdir = 'l'; }
	else if (match == 'A' &amp;&amp; dir == 'r') {  newdir = 'r'; }
	else if (match == '&lt;' &amp;&amp; dir == 'u') {  newdir = 'l'; }
	else if (match == '&lt;' &amp;&amp; dir == 'r') {  newdir = 'd'; }
	else if (match == '&gt;' &amp;&amp; dir == 'u') {  newdir = 'r'; }
	else if (match == '&gt;' &amp;&amp; dir == 'l') {  newdir = 'd'; }
	else return 666;
	if      (newdir == 'd') { newcol = col;   newrow = row+1; }
	else if (newdir == 'r') { newcol = col+1; newrow = row;   }
	else if (newdir == 'l') { newcol = col;   newrow = row;   }
    }
    else if (type == 'w') {
	char match = white[row][col];
	newtype = 'b';
	if      (match == 'V' &amp;&amp; dir == 'l') { newdir = 'l'; }
	else if (match == 'V' &amp;&amp; dir == 'r') { newdir = 'r'; }
	else if (match == '&lt;' &amp;&amp; dir == 'd') { newdir = 'l'; }
	else if (match == '&lt;' &amp;&amp; dir == 'r') { newdir = 'u'; }
	else if (match == '&gt;' &amp;&amp; dir == 'd') { newdir = 'r'; }
	else if (match == '&gt;' &amp;&amp; dir == 'l') { newdir = 'u'; }
	else { return 20000; }
	if (newdir == 'l') { newcol = col-1; newrow = row;   }
	if (newdir == 'u') { newcol = col;   newrow = row-1; }
	if (newdir == 'r') { newcol = col;   newrow = row;   }
    }
    //if that next tile==terminal, return terminal.
    int x = amterm(newtype, newrow, newcol);
    if (x != 0) {
	return x;
    }
    //else return rmove of next tile...
    else {
	return rmove(newtype, newrow, newcol, newdir) ;
    }
}

int Hexagon::amterm(char type, int row, int col) { 
    if (type == 'b') {
	if (row == 2*size-1) {
	    return (4*size)-col ;
	}
	else if (col == 2*size-1) {
	    return size+1+row;
	} 
	else if (col+row == size-1) {
	    return 5*size+col+1;
	}
	else { 
	    return 0;
	}
    }
    else if (type == 'w') {
	if (row == 0) {
	    return  (col -size +1) ;
	}
	else if (col == 0) {
	    return (6*size-row);
	} 
	else if (col+row == (3*size)-1) {
	    return (row+size+1);
	}
	else { 
	    return 0;
	}
    }
    else {
	return 0;
    }
}
 
int main(int argc, char *argv[]) {
    int size = 0;
    if (argc == 1) {
	cerr &lt;&lt; &quot;How big do you want your hexagon?\n&quot;
	     &lt;&lt; &quot;Usage: hexagon size [options]\n&quot; 
	     &lt;&lt; &quot;``size'' is the size of the hexagon \n&quot;
	     &lt;&lt; &quot;\tOptions:\n&quot;
	     &lt;&lt; &quot;\tg = print Gelfand Square\n&quot; 
	     &lt;&lt; &quot;\th = print Hexagon\n&quot;
	     &lt;&lt; &quot;\tc = count tilings\n&quot;
	     &lt;&lt; &quot;\tm = do not print matchings\n&quot;   
	     &lt;&lt; &quot;example:  ./hexagon 2 hc \n&quot;;
	return 1;
    }
    else {
	if (size = abs(atoi(argv[1])) ) {
	    if ( size &gt; MAXSIZE ) {
		size = MAXSIZE ;
	    }
	}
	else {
	    cerr &lt;&lt; &quot;Usage: gelfand size [options]&quot; &lt;&lt; endl
		 &lt;&lt; &quot;and ``size'' is an positive integer less than &quot; 
		 &lt;&lt; MAXSIZE &lt;&lt; &quot;.&quot;&lt;&lt; endl;
	    return 1;
	}
    }
    int printGSon = 0;
    int printBWon = 0;
    int counton = 0;
    int printMatchings = 1;
    if (argc &gt;= 3) {
	for(int i = 0; argv[2][i] != '\0' ; i++) {
	    if (argv[2][i] == 'g') 
		printGSon = 1;
	    if (argv[2][i] == 'h')
		printBWon = 1;
	    if (argv[2][i] == 'c')
		counton = 1;
	    if (argv[2][i] == 'm')
		printMatchings = 0;
	}
    }
    
    Hexagon hex(size);
    long count = 1;
    long count2 = 0;

    if (printGSon ==1) {
	hex.printGS(cout);
	cout &lt;&lt; endl;
    }
    if (printBWon == 1 || printMatchings == 1)
	hex.makeBW();
    if (printBWon == 1)
	hex.printBW(cout);
    if (printMatchings == 1)
	hex.printMatchings(cout);
    if (printBWon == 1) 
	cout &lt;&lt; endl;

    while (hex.iterate() == 0) {
	if (counton == 1){
	    if (count == 1999999999) {
		count = 0;
		count2++;
	    }
	    else {
		count++;
	    }
	}
	if (printGSon ==1) {
	    hex.printGS(cout);
	    cout &lt;&lt; endl;
	}
	if (printBWon == 1 || printMatchings == 1)
	    hex.makeBW();
	if (printBWon == 1) 
	    hex.printBW(cout);
	if (printMatchings == 1)
	    hex.printMatchings(cout);
	if (printBWon == 1) 
	    cout &lt;&lt; endl;
    }
    if (counton == 1) {
	if (count2==0) 
	    cout &lt;&lt; &quot;Total number of tilings = &quot; &lt;&lt; count &lt;&lt; endl;
	else 
	    cout &lt;&lt; 2*count2 &lt;&lt; &quot;000000000 + &quot; &lt;&lt; count &lt;&lt; endl;
    }
    return 0; 
}
</code></pre>
<hr />
<div class="rightside"><em>file modification time: 2003-12-08 05:33:47</em></div>

</article>
<div class="rightside">
<em>https://halcanary.org</em>
<br/>
<em>Copyright 2002-2023 Hal Canary.</em>
<br/>
<em>ALL RIGHTS RESERVED.</em>
</div>
</body>
</html>
