<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--
    TOAD Shuffler  v1.9.0
    Copyright  2001-2002,2018  Hal Canary

    This program is free software; you can redistribute it and/or
    modify it under the terms of version 2 of the GNU General Public
    License as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->
<title>TOAD Shuffler</title>
<style>
body{margin:0 auto 8px auto;max-width:602px;padding:0 8px;}
h1 { margin: 0 -8px;
     padding: 0 16px;
     background-color: #e6e6e6;
     border-top: 1px solid black }
div.help { padding: 0 8px; }
p.reference{ padding-left: 2em;
             text-indent: -2em; }
#c { width: 100%; height:100%; }
</style>
<script>
class Tiling {
    constructor() {
        this.none = 0;
        this.N = 1;
        this.E = 2;
        this.W = 3;
        this.S = 4;
        this.arraySize = 64;
        this.domArray = this.newA(this.arraySize);
        this.n = 1;
        this.step = 2;
        this.fillAll();
    }

    newA(asize) {
        var s = asize * (1 + asize);
        var a = new Uint8Array(s);
        for (var i = 0; i < s; ++i) {
            a[i] = this.none;
        }
        return a;
    }

    get(r, c) { return this.domArray[r * this.arraySize + c]; }

    set(r, c, v) { this.domArray[r * this.arraySize + c] = v; }

    fillAll() {
        if (this.step != 2) { return; }
        for(var r = 0 ; r < this.n ; r++) {
            for(var c = 0 ; c < this.n ; c++) {
                if (this.get(r, c) == this.none &&
                    this.get(r+1, c) == this.none) {
                    if (Math.floor(Math.random() * 2) == 1) {
                        this.set(r, c, this.N);
                        this.set(r+1, c, this.S);
                    } else {
                        this.set(r, c, this.E);
                        this.set(r+1, c, this.W);
                    }
                }
            }
        }
        this.step = 0;
    }

    annihilateAll() {
        if (this.step != 0) { return; }
        for(var r = 1 ; r < this.n + 1 ; r++) {
            for(var c = 0 ; c < this.n - 1 ; c++) {
                if ( (this.get(r, c) ==this.E && this.get(r, c+1) ==this.W ) ||
                     (this.get(r, c) ==this.S && this.get(r, c+1) ==this.N ) ) {
                    this.set(r, c, this.none);
                    this.set(r, c+1, this.none);
                }
            }
        }
        this.step = 1;
    }

    moveAll() {
        if (this.step != 1) { return; }
        if (this.n + 1 > this.arraySize) {
            var newSize = 2 * this.arraySize;
            var newArray = this.newA(newSize);
            for (var r = 0 ; r < this.n + 1 ; r++) {
                for (var c = 0 ; c < this.n ; c++) {
                    newArray[r * newSize + c] = this.get(r, c);
                }
            }
            this.arraySize = newSize;
            this.domArray = newArray;
        }
        for (var r = this.n; r >= 0; --r) {
            for (var c = this.n - 1; c >= 0; --c) {
                switch (this.get(r, c)) {
                    case this.N:
                        break;
                    case this.S:
                        this.set(r, c, this.none);
                        this.set(r+1, c+1, this.S);
                        break;
                    case this.E:
                        this.set(r, c, this.none);
                        this.set(r, c+1, this.E);
                        break;
                    case this.W:
                        this.set(r, c, this.none);
                        this.set(r+1, c, this.W);
                        break;
                }
            }
        }
        this.n++;
        this.step = 2;
    }
/*   (r,c)     (0,0)
        rows     N   columns
                N N
      <--r     N N N      c-->
              N N N E
             S S S W E  (0,n-1)
     (n,0)  W N S E N
             S W N S
              S S S
               S S
                S
              (n,n-1)
*/

    draw(canvas, scale) {
        var ctx = canvas.getContext("2d");
        var w = Math.floor((canvas.width  - 1) / 2) * 2;
        var h = Math.floor((canvas.height - 1) / 2) * 2;
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        var dim = Math.min(w, h);
        if (scale * 2 * this.n > dim) {
            scale = Math.max(2, Math.floor(dim / (this.n * 2)));
        }
        for(var r = 0 ; r < this.n + 1 ; r++) {
            for(var c = 0 ; c < this.n ; c++) {
                var x = w / 2 + (- r + c) * scale + 0.5;
                var y = h / 2 + (r + c - this.n) * scale + 0.5;
                var color = "";
                var vert = false;
                switch (this.get(r, c)) {
                    case this.N:
                        color = "#A6CEE3";
                        x -= scale;
                        break;
                    case this.S:
                        color = "#1F78B4";
                        break;
                    case this.E:
                        color = "#B2DF8A";
                        vert = true
                        break;
                    case this.W:
                        color = "#33A02C";
                        y -= scale;
                        vert = true;
                        break;
                }
                if (color) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x + 0.5, y + 0.5,
                                 scale * (vert ? 1 : 2) - 0.5,
                                 scale * (vert ? 2 : 1) - 0.5);
                    if (scale > 2) {
                        ctx.fillRect(x + 0.5, y + 0.5,
                                     scale * (vert ? 1 : 2) - 0.5,
                                     scale * (vert ? 2 : 1) - 0.5);
                        ctx.strokeRect(x, y, scale * (vert ? 1 : 2), scale * (vert ? 2 : 1));
                    } else {
                        ctx.fillRect(x + 0.5, y + 0.5,
                                     scale * (vert ? 1 : 2) + 0.5,
                                     scale * (vert ? 2 : 1) + 0.5);
                    }
                } else {
                    ctx.fillStyle = "#DDDDDD";
                    ctx.fillRect(x+0.5, y + 0.5, scale - 1, scale - 1);
                }

            }
        }
    }
}

var t;
var canvas;
var scale = 10;

function init() {
    var limit = 1;
    canvas = document.getElementById('c');
    newAD();
}

function newAD() {
    var s = document.getElementById('initialSize').value;
    t = new Tiling();
    while (t.n < s) {
        t.annihilateAll();
        t.moveAll();
        t.fillAll();
    }
    drawAll();
}

function drawAll() {
    t.draw(canvas, scale);
    document.getElementById('size').innerHTML = t.n;
}

function iterateStage() {
    t.annihilateAll();
    t.moveAll();
    t.fillAll();
    drawAll();
}

function iterateStep() {
    switch (t.step) {
        case 0:
            t.annihilateAll();
            break;
        case 1:
            t.moveAll();
            break;
        case 2:
            t.fillAll();
            break;
    }
    drawAll();
}

</script>
</head>
<body onload="init();">
<h1>TOAD Shuffler  v1.9.0</h1>

<p>
<button onclick="iterateStep()">Iterate Step</button> &nbsp;
<button onclick="iterateStage()">Iterate Stage</button> &nbsp;
Current Size: <span id='size'>1</span> &nbsp;
<br>
<button onclick="newAD()">New Aztex Diamond</button> &nbsp;
Initial Size: <input type="text" value="1" id="initialSize" size="4"></input>
<br>
<canvas id="c" width="602" height="602"></canvas>
</p>

<h1>TOAD Shuffler Help</h1>

<div class="help">

<h2>What is it?</h2>

<p>
A TOAD is a Tiling Of an Aztec Diamond with domino tiles; a domino is
a 2-by-1 rectangle.  Set &ldquo;Initial Size&rdquo; to 2.  Then click
on &ldquo;New AD.&rdquo; TOAD Shuffler will now display an random
Aztec Diamond of order 2.  Hit &ldquo;Iterate Stage&rdquo; several
times.  Each time, it will display a larger Aztec Diamond, tiled with
dominoes.
</p>

<p>
An order <i>n</i> Aztec diamond has 2^(<i>n</i>(<i>n</i>+1)/2)
different tilings.  This program will produce a random tiling from the
uniform distribution of all such tilings.
</p>

<h2>What are the rules?</h2>

<p>
There are three steps to &ldquo;growing&rdquo; a TOAD via the EKLP shuffling
algorithm.  They are filling, destruction, and sliding.
</p>

<p>
<i>Rule for Filling:</i>
<br>
Divide the untiled area into squares.  Then randomly tile each square
with either two horizontal dominoes or two vertical dominoes.
</p>

<p>
<i>Rule for Destruction:</i>
<br>
If a north-going domino is about to collide with a south-going domino,
delete them both.  Same for east and west-going dominoes.
</p>

<p>
<i>Rule for Sliding:</i>
<br>
Move the horizontal dominoes north or south, depending on their color.
Move the vertical dominoes east or west, depending on their color.
</p>

<h2>What do the colors mean?</h2>

<p>The colors of each tile represent the direction that they will move in
the sliding step of the shuffling algorithm.  But the colors come from
the position of the tiles.  Imagine the Aztec diamond as a large
checkerboard where each domino overlaps two squares, a black and a
white square.  if the black square is to the left of the white square,
color it one color, if the black square is to the right, color it
another color. The same applies to the two colors of vertical dominoes.
</p>

<!--
<h2>What is a FPL?</h2>

<p>
A FPL (Fully Packed Loop) is a way to represent an ASM (Alternating
Sign Matrix.)  Each TOAD corresponds to two ASMs.  If you turn on
&ldquo;Show FPL,&rdquo; TOAD Shuffler will display the two FPLs that
correspond to the two ASMs that correspond to the TOAD.
</p>
-->

<h2>Credits.</h2>

<p>
TOAD Shuffler is Copyright 2001-2004, 2018 Hal Canary, University of
Wisconsin-Madison.
</p>

<p>Hal Canary <a href="#ref">[1]</a> wrote TOAD Shuffler in the Spring
of 2001 while working with the Spatial Systems Lab (SSL) <a
href="#ref">[2]</a> at the University of Wisconsin-Madison.  This work
is based on the program shuffle.tcl by Matthew Blum. <a
href="#ref">[3]</a> TOAD Shuffler demonstrates the domino shuffling
algorithm from Elkies, Kuperberg, Larson, and Propp. <a
href="#ref">[4]</a> <a href="#ref">[5]</a>
</p>

<p>
SSL is sponsored by the National Science Foundation through their
VIGRE (Vertical Integration of Graduate Research and Education)
program, with supplemental support from the National Science
Foundation's REU (Research Experiences for Undergraduates) program and
from the National Security Agency.
</p>

<p>
TOAD Shuffler comes with ABSOLUTELY NO WARRANTY.  This program is free
software; you can redistribute it and/or modify it under the terms of
version 2 of the <a href="./LICENSE.md">GNU General Public
License</a> as published by the Free Software Foundation.
</p>

<h2><a name="ref"></a>References:</h2>
<p class="reference">
<span style="width:2em;">[1]</span>
<a href="http//halcanary.org/"> halcanary.org/</a>
</p>
<p class="reference">
[2]
<a href="https://faculty.uml.edu/jpropp/SSL/">faculty.uml.edu/jpropp/SSL/</a>
</p>
<p class="reference">
[3]
<a href="https://faculty.uml.edu/jpropp/software.html">faculty.uml.edu/jpropp/software.html</a>
</p>
<p class="reference">
[4]
N. Elkies, G. Kuperberg, M. Larsen, and J. Propp.
&ldquo;Alternating-Sign Matrices and Domino Tilings (Part I).&rdquo;
<i>Journal of Algebraic Combinatorics</i> 1 (1992) 111-132.
<br>(<a href="https://doi.org/10.1023/A:1022420103267">doi.org/10.1023/A:1022420103267</a>)
</p>

<p class="reference">
[5] Jim Propp
&ldquo;The many faces of alternating-sign matrices.&rdquo;
&ldquo;Discrete Models: Combinatorics, Computation, and
 Geometry&rdquo; (special issue of <i>Discrete Mathematics and
Theoretical Computer Science</i>), July 2001
<br>(<a href="http://arxiv.org/abs/math.CO/0208125">arXiv:math.CO/0208125</a>)
</p>

<p>&nbsp;</p>

</div>
</body>
</html
